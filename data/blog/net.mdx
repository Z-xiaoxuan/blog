---
title: '网络'
date: '2025-08-29'
tags: ['code-tool']
draft: true
summary: '面经'
---

# 分层模型
网络问题很复杂，我们需要分层去解决不同的问题

四层是早期软件公司的分层模型，七层是教科书中的（太细了）

分层是为了相对独立，去解决一下问题，五层比较通用

## 五层网络模型
应用层：HTTP/HTTPS URL协议等
传输层：TCP（可靠传输协议）/ UDP（不可靠传输协议）
网络层：IP地址，路由（茫茫的网络中，寻找最优路径解）（IP：动态唯一，像家庭住址，MAC地址，像指纹）
数据链路层：在局部的网络中，如何精准的发送到目的地址 MAC地址（打在网卡上）
物理层：信号如何传播

## URL（统一资源定位符）
找到你想要的互联网中的服务

由协议（schema）、域名、端口、path、query、hash（网络中没有作用）组成。

www.baidu.com/ 最后面这个是根路径，如果没有写，浏览器会自动补全

URL是URI的子集，一个请求资源的URL并不能说明该资源一定存在在域名主机中。URL只是后端程序生成结果的依据。

把path和文件路径对应起来的程序，是静态资源服务器。（live-server插件）

##  HTTP

消息传递的模式：请求-响应模式

在某一次请求的前提下，才可以区分客户端和服务器。

```
请求行
请求头（可以有多行，键值对）

请求体
```

请求样例

```
GET / HTTP/1.1
Host: www.taobao.com
```
GET：只是用来表达语意的（可以随便写），服务器认识就有效。认不认识要问服务器人员
/：表示路径 + query
HTTP/1.1：固定的，表示协议版本

Host：访问域名（这个请求头必须写，其他需要前后人员协商）
Content-Type：告诉服务器请求体的格式 x/y(MIME) (application/x-www-form-urlencoded) (application/json)  (multipart/form-data; boundary=-aaa 这种格式主要用于文件上传)

```
POST /api/user/login HTTP/1.1
Host: study.duyiedu.com
Content-Type: multipart/form-data; boundary=aaa

--aaa
Content-Disposition: form-data; name="loginId"

admin
--aaa
Content-Disposition: form-data; name="loginPwd"

123456

--aaa
Content-Disposition: form-data; name="avatar"
fileName="avatar.jpg"
Content-type: img/jpeg

文件的二进制数据(base64)
--aaa--
```

响应

```
响应行
响应头

响应体
```

```
HTTP/1.1 200 OK 后面这俩由程序控制
Content-Type: text/html

响应体
```

1开头：信息，需要请求者继续进行操作
2开头：成功
3开头：重定向、缓存（301永久重定向，下次直接访问新的，302临时重定向） 通过响应头Location来重定向，浏览器操作的
4开头：客户端错误（40协议错误 请求协议错误，）
5开头：服务器错误 

# 用户代理
浏览器称为用户代理，之所以被称为用户代理，是因为浏览器可以代替用户发请求和解析响应。

## 什么时候浏览器代理发请求（必须要有完整的URL地址）
1. 导航栏
2. 点击<a/>元素。

    假如当前页面的URL地址为：http://www.baidu.com:80/a/b/c.html

    a元素的href属性有两种表示方式：绝对路径和相对路径

    绝对路径：补全的URL和当前页面path完全没有关系。如果不全， 缺少协议就根据当前页面协议补全，缺少域名就根据当前页面域名补全，缺少端口就根据当前页面端口补全。
    
    两种写法： 
            1. <a href="//www.taobao.com/">第一种：//www.taobao.com/</a> 会自动补全为 http://www.taobao.com/
            2. <a href="/">第二种: /</a> 会自动补全为 http://www.baidu.com/

    相对路径：相对的是当前页面的path路径

    两种写法：

    第一种：./index.html 会补全为 http://www.baidu.com:80/a/b/index.html

    第二种：../index.html 会补全为 http://www.baidu.com:80/a/index.html

3. 当用户点了表单的提交按钮（现代一般不这样做，但是可以利用回车登录） 填写form元素的action和method属性后，点击提交按钮会发出后请求。它请求体的格式默认为 application/x-www-form-urlencoded

4. 当解析HTML时遇到了`<img>` `<link>` `<script` `<video>` `<audio>`等元素

5. 用户点击刷新


## 自动解析响应的能力

1. 能够自动识别响应码，当出现一些特殊的响应码时，浏览器会自动完成处理。如：301，302
2. 能根据响应结果`Content-Type`做不同处理


# AJAX
早期浏览器并没有把网络通信下放给JS

浏览器发请求，如：form表单、a元素，都会刷新浏览器。但是JS并不会。

JS发有两种方式（都叫AJAX）：
1. xhr（老了）事件风格
2. Fetch（还在维护更新，但是做不了进度）Promise风格。响应结果是分阶段的，分为响应行+响应头和响应体（可以解析成不同的格式） （ArrayBuffer：只读的空间连续的的定长字节数）

```js
// 文件上传进度
const strs = ['fa','fs','ewq']

const map = new Map()

for(const str of strs){
    map.set(str)
}

while(){
    map.get()
}
```

```js
// gpt效果
const content = "提问的问题"

const resp = await  fetch('主机名',{
    method:'POST',
    headers:{
        'Content-Type':'application/json'
    }
    body:JSON.stringify({
        content
    })
})

// const body = await resp.text() // 解析为纯文本

//流式读取
const reader = resp.body() // 拿到读取器
const decoder = new TextDecoder()
while(true){
    const {value,done} = await reader
    if(done){
        break
    }
    console.log(decoder.decode(value))
}

// new EventSource
```

# 跨域

受到浏览器的同源策略影响，从而产生了跨域的问题

同源：协议、域名、端口都相同

异源就会导致跨域的问题

## 造成跨域情景
*  网络通信
    - a元素跳转、加载css、js、图片、视频等、AJAX等
* JS api
    - window.open window.parent、iframe
* 存储
    - webStorage、indexDB等
    
### AJAX跨域
三种解决办法：CORS、JsonP、代理
#### CORS
CORS规则就是浏览器校验规则：
1. 服务器明显表示可以就可以通过，如果没有明确表示就不行

请求分类：CORS将请求分为两类：**简单请求**和**预检请求**

简单请求的定义：
1. 请求方法是`GET`、`POST`、`HEAD`之一
2. 头部字段（请求头）满足CORS安全规范（开发者不要动就不会打破）
3. Content-Type 只能是 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

其余的都是预检请求

#### 对简单请求的检验规则

客户端会在请求头携带一个受保护字段，`Origin` 来表示请求的来源（代码不可更改）。

服务器返回的响应头中，会携带`Access-Control-Allow-Origin`字段来表示允许的来源（代码可更改）。如果键中有 `Origin` 的值，就表示允许跨域。也可以写 `*` 表示允许所有来源。

#### 对预检请求的检验规则

跨域如果是非简单请求，需要先发送一个预检请求，判断当前请求是否可以通过。预检是为了防止对服务器的危险操作。

1. 浏览器拦截请求，自己发一个请求，携带以下信息：
    - Origin: http://my.com
    - Access-Control-Request-Method: POST
    - Access-Control-Request-Headers: 这里添更改了的请求头的key值

2. 如果服务器希望通过，那么响应头中至少会携带：去告诉浏览器那些可以
    - Access-Control-Allow-Origin: http://my.com
    - Access-Control-Allow-Methods: POST
    - Access-Control-Allow-Headers: 这里添更改了的请求头的key值
    - Access-Control-Max-Age: 86400 这个字段是表示在这段时间内不用再预检了

通过之后就是简单请求了

#### 细节1
跨域请求是不会携带cookie的，可以通过相关配置实现
```js
// xhr
var xhr = new XMLHttpRequest()
xhr.withCredentials = true

// fetch
fetch(url,{
    credentials:'include'
})
```

同时服务器也要通知浏览器：
```js
Access-Control-Allow-Credentials: true
```

**对于附带身份凭证的请求，服务器不能将`Access-Control-Allow-Origin`设置为`*`**

#### 细节2
跨域获取响应头，需要服务器在响应时，暴露哪些头部
```js
Access-Control-Expose-Headers: 可以暴露的响应头的key值
```

#### JsonP
JsonP是通过`<script>`标签来实现的，

客户端准备一个全局函数

```js
function callback(resp){
    console.log("来自服务器的响应==>",resp)
}
<script src="跨域的请求源"></script>
```

服务器要返回一段js代码，是对客户端全局函数的调用
```js
callback({
    msg:'客户端想要的信息'
})
```
> 两边的函数名一定要统一

#### 代理
代理是通过服务器来实现的


# cookie

http协议是无状态协议，下一次请求不会知道上一次是什么样的。以前的浏览器想要保存状态，就需要响应值设置cookie。

可以把cookie看作是一个卡包，管理着各个网站的身份信息。

在浏览器发送请求时，会自动携带哪些cookie？

1. 没有过期
2. 域是否匹配？只要是主域和子域的关系就可以
3. 路径是否匹配？ 
4. 是否是安全传输

具体操作？

假设有三个cookie符合要求，那么会在请求头中添加Cookie字段：`Cookie: a=1;b=2;c=3`

cookie的来源？

1. 服务器的响应头携带设置cookie的头。
2. 客户端自己设置

如果没有设置cookie过期时间，那么代表退出当前会话，cookie过期。


# 加密

1. 对称加密

    明文 ==加密(密钥)==> 密文 ==解密(密钥)==> 明文

    缺点：有安全性问题，需要传输密钥

2. 非对称加密

    公钥加密，私钥解密

    缺点：只有一方可以解密

3. 摘要

    明文 =算法(MD4、MD5)=> 密文

    缺点：理论上可以还原，但是现在无法还原

# Cookie和Session

Cookie是存储在客户端的，Session是存储在服务器的。

典型的应用场景：登录操作

1. 登录成功后，服务器设置session
2. 服务器设置cookie：sessionId
3. 客户端发请求
4. 服务器接受请求，获取cookie中的sessionId
5. 业务逻辑

#  HTTP协议缓存

是服务端和客户端协商出来的。

如何实现？服务器在首次请求的时候，响应头设置以下几个字段：

比如一些静态资源：
```js
Catch-Control:  max-age=3600  // 缓存多长时间
ETag: 1234567890 // 服务器生成的唯一标识
Last-Modified: 2025-09-09T16:13:39+08:00 // 最后修改时间
Date: 2025-09-09T16:13:39+08:00 // 服务器的时间
```

下次再请求：

如果资源有效：那么浏览器直接从缓存中读取，不发送请求

如果资源失效：

    先发一个带有缓存的请求，主要就是问服务器资源到底变了没？


    ```js
    If-Modified-Since: 2025-09-09T16:13:39+08:00 // 这个是上次缓存，资源的缓存时间。在这个时间之后，资源没有被修改过？
    If-None-Match: 1234567890 // 这个是上次缓存，资源的唯一标识。如果资源没有被修改过？
    ```

    - 如果变了：直接返回最新的内容
    - 如果没变：返回 304 not modified；没有响应体


# CSRF攻击
    
跨站请求伪造

原理：

1. 访问者登录正常网站，浏览器存储了对应的cookie身份信息
2. 访问者访问恶意网站，通过`img`等标签来请求正常网站的接口（同源策略但不阻止跨域请求发送cookie）
3. 实现攻击

**防御方式**
1. 不使用cookie，但是牺牲了兼容性和SSR
2. 使用samesite字段，响应中的set-cookie头中设置samesite字段，三个取值：none、strict（只有当前地址和请求地址源相同才可以）、lax（有些请求可以带cookie，也有些请求不可以）。但是容易挡住自己人
3. 使用csrf token，
4. 使用referer字段：该字段表示这个请求从哪里来的

# XSS攻击（CSS）

跨站脚本攻击：在提交表单的内容中，插入恶意的JS代码，将来等正常用户访问时，这段代码在正常用户的客户端执行实现攻击。

**防御方式**
1. 过滤：对提交的任何信息进行过滤，危险标签和属性
2. 编码

# 网络优化

1. 优化打包体积
2. 多目标打包：对不同版本的浏览器打不同的包，减少一些浏览器不必要的兼容性代码
3. 压缩：现代浏览器普遍支持压缩格式，因此服务器可以将打包后的文件再次压缩后传输给客户端。只要保证解压时间小于所优化的传输时间就可行
4. CDN：缩短网络路径，减少原服务器压力。更新有延迟。对于一些知名的三方库，通过浏览器的缓存，可以夸网站使用缓存资源。
5. http2
6. 雪碧图
7. defer，async 让浏览器尽快的加载JS资源
8. prefetch、preload：让浏览器提早加载一些必要的资源。- 页面空闲的时候，下载其他页面的东西。- 预先下载本页的资源
9. 多个静态资源域：不加干涉如果一个域tcp连接最多开6个。

# 断点续传

**下载**

通过`响应头`以下字段来确定是否可以断点:

Content-Disposition 响应头最初的设计目的是为了指定接收方（通常是浏览器）应该如何处理传输过来的内容。它主要有两种作用：

    - 内联（inline）：默认行为。指示内容应该被显示在网页内部，即作为页面的一部分。例如，浏览器会直接在标签页中显示图片、PDF文件（如果浏览器支持），或者将文本内容显示出来。

    - 附件（attachment）：指示内容应该被下载到本地，而不是在浏览器中显示。这是它最著名的用法，用于触发文件的下载。

Accept-Ranges: 用于表明该服务器是否支持对特定资源的范围请求（Range Requests）。
Content-Length: 文件大小

服务器通过`请求头`中的Range，来确定返回的范围，下载工具发请求

Range：每次传输的chunk的大小。

**上传**

用户选择文件后，把文件以及文件切片的MD5值发给服务器，与服务器进行协商。

# 域名和DNS

域名解析流程：

1. 先从本机的HOST文件中，查询是否有对应的ip地址，有返回ip，没有继续下一步
2. 向本地域名服务器查询，有，返回ip，没有继续一下步
3. 本地域名服务器代表客户端，以迭代查询的方式向全球DNS层级系统（根→顶级域→权威域）发起查询，并将最终结果以递归的形式返回给客户端，如果没有执行下一步
4. 解析失败，返回错误

# SSL、TLS、HTTPS的关系

客户端和服务器通信的时候，数据会经过多个网络节点，这些节点可能会被黑客篡改，所以需要安全措施来保证数据的安全性。

SSL和TSL就是为了保证数据的安全性，在tcp和http中间增加的一层安全层。

前期准备：

服务器：申请证书
客户端：https访问，默认端口443

1. 服务器返回的证书：带有域名、发行者、有效期、服务器的公钥、以及CA用自身私钥对前面所有信息进行哈希计算后得到的数字签名
2. 客户端拿到证书后，浏览器使用相同的哈希算法，对证书明文信息（包括服务器的公钥）计算得到摘要和用内置的CA公钥解密签名，得到摘要相比，验证完整性。
3. 客户端生成密钥，用服务器的公钥加密，传输给服务器
4. 生成会话密钥：双方用两个随机数和预主密钥，独立计算出相同的会话密钥。
5. 开始数据传输

# HTTP 版本的差异

**http1.0**

问题：
1. 无法复用连接：每个请求都要传输层的三次握手，四次挥手。问题：连接和销毁会消耗内存空间和时间；无法充分利用带宽（每次都是tcp的慢启动）。
2. 对头阻塞：上一个请求完成前，下一个请求无法发送。

**http1.1**

解决了：
1. 长连接：tcp连接的复用。
2. 管道化：解决对头阻塞的问题，可以同时发多个请求，但是返回的顺序要和发送的顺序一致。（默认不开启）


问题：
1. 对头阻塞：上一个请求完成前，下一个请求无法发送。

解决不了对头阻塞的原因：http请求不能拆开（请求行、请求头、请求体）

**http2**

必须是https

1. 对头阻塞： 将请求单元从http协议拆分到二进制帧。

每一个请求或者响应都称为一个`流`,每个流都是独立的且有编号，可以并行传输。而每个帧都有所属的流。

2. 头部压缩：两端都各存一张静态图和动态图，用来标记请求头。通过传输标记来代替原始的请求头。

3. 服务器推：没有请求，服务器主动推送给客户端。


问题：
有TCP的对头阻塞问题

**http3.0**

抛弃TCP使用QUIC（基于UDP）协议

# websocket

实时性场景旧方法：

1. 短轮训：客户端每隔一小段时间，就请求服务器是否有新数据。
2. 长轮训：客户端请求服务器，服务器没有新数据，就一直不返回，直到有新数据。

socket：

建立在TCP上

1. 握手
2. 发送数据
